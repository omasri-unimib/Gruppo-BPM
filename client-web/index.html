<!DOCTYPE html>
<html>

  <head>
    <title>Cinema Multisala</title>
  </head>

  <body>
    <h2>Prossime proiezioni</h2>

    <table border="1">
      <thead>
        <tr>
          <th>ID</th>
          <th>ID Screening</th>
          <th>Film</th>
          <th>Data</th>
          <th>Orario</th>
          <th>Sala</th>
          <th>Posti</th>
        </tr>
      </thead>
      <tbody id="table-body">

      </tbody>
    </table>
    <script>
      const API_URI = "http://localhost:8080";

      // getUsers restituisce i contatti nella rubrica telefonica.
      async function getProjections() {
        // Bisogna effettuare i seguenti passi:
        //
        //	1. Chiamare GET "http://localhost:8080/contacts",
        //	2. Controllare che la chiamata abbia avuto successo,
        //	3. Restituise l'oggetto (lista di contatti) facendo il parsing del JSON.

        // L'interpolazione di stringhe permette di inserire espressioni in un
        // letterale. Comodo per costruire stringhe speciali.
        //
        // Info: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals
        const endpoint = `${API_URI}/screening`;

        // Senza parametri, a parte l'URL, fa una chiamata GET. fetch è
        // asincrona, per questo uso await.
        const response = await fetch(endpoint);

        // Controllo di eventuali errori.
        if (!response.ok)
          throw new Error(`Response from "${endpoint}" was not successful: ${response.status} ${response.statusText}`);

        // Effettua il parsing del JSON e restituisce l'oggetto. Il parsing
        // avviene in modo asicrono, per questo uso "await".
        return await response.json();
      }

      async function getMovie(id) {
        // Bisogna effettuare i seguenti passi:
        //
        //	1. Chiamare GET "http://localhost:8080/contacts",
        //	2. Controllare che la chiamata abbia avuto successo,
        //	3. Restituise l'oggetto (lista di contatti) facendo il parsing del JSON.

        // L'interpolazione di stringhe permette di inserire espressioni in un
        // letterale. Comodo per costruire stringhe speciali.
        //
        // Info: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals
        const endpoint = `${API_URI}/movie/${id}`;

        // Senza parametri, a parte l'URL, fa una chiamata GET. fetch è
        // asincrona, per questo uso await.
        const response = await fetch(endpoint);

        // Controllo di eventuali errori.
        if (!response.ok)
          throw new Error(`Response from "${endpoint}" was not successful: ${response.status} ${response.statusText}`);

        // Effettua il parsing del JSON e restituisce l'oggetto. Il parsing
        // avviene in modo asicrono, per questo uso "await".
        return await response.json();
      }

      async function getHalls() {
        // Bisogna effettuare i seguenti passi:
        //
        //	1. Chiamare GET "http://localhost:8080/contacts",
        //	2. Controllare che la chiamata abbia avuto successo,
        //	3. Restituise l'oggetto (lista di contatti) facendo il parsing del JSON.

        // L'interpolazione di stringhe permette di inserire espressioni in un
        // letterale. Comodo per costruire stringhe speciali.
        //
        // Info: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals
        const endpoint = `${API_URI}/hall`;

        // Senza parametri, a parte l'URL, fa una chiamata GET. fetch è
        // asincrona, per questo uso await.
        const response = await fetch(endpoint);

        // Controllo di eventuali errori.
        if (!response.ok)
          throw new Error(`Response from "${endpoint}" was not successful: ${response.status} ${response.statusText}`);

        // Effettua il parsing del JSON e restituisce l'oggetto. Il parsing
        // avviene in modo asicrono, per questo uso "await".
        return await response.json();
      }

      // getContact restituisce il singolo contatto.
      async function getContact(id) {
        // La funzione è molto simile a getContacts. Bisogna effettuare i
        // seguenti passi:
        //
        //	1. Chiamare GET "http://localhost:8080/contacts/{id}",
        //	2. Controllare che la chiamata abbia avuto successo,
        //	3. Restituise l'oggetto (il contatto) facendo il parsing del JSON.
        const endpoint = `${API_URI}/contacts/${id}`;

        const response = await fetch(endpoint);

        if (!response.ok)
          throw new Error(`Response from "${endpoint}" was not successful: ${response.status} ${response.statusText}`);

        return await response.json();
      }

      // newContact aggiunge un contatto al server, restituisce il nuovo ID.
      async function newContact(contact) {
        // Bisogna effettuare i seguenti passi:
        //
        //	1. Chiamare POST "http://localhost:8080/contacts" con
        //		 nel body la rappresentazione JSON del nuovo utente,
        //	2. Controllare che la chiamata abbia avuto successo,
        //	3. Controllare l'header "Location", estrarre l'ID alla fine
        //		 e restituirlo.
        const endpoint = `${API_URI}/contacts`;

        // In questo caso nella fetch devo passare delle opzioni:
        //	* method: per indicare il metodo utilizzato,
        //	* headers: gli header utilizati,
        //	* body: il body della richiesta.
        const response = await fetch(endpoint, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify(contact)
        });

        if (!response.ok)
          throw new Error(`Response from "${endpoint}" was not successful: ${response.status} ${response.statusText}`);

        const location = response.headers.get("Location");

        // Fa lo split e restituisce l'ultima sottostringa, che è l'ID.
        return location.split("/").pop();

      }

      // Funziona di utilità che mostra l'errore nella console e in un alert
      // del browser.
      function onError(msg, error) {
        const out = `${msg}: ${error}`;
        console.error(out);
        alert(out);
      }

      // newContactDOM viene eseguita all'invio del from. Aggiunge un nuovo
      // contatto, prima inviandolo al server e poi mettendolo nella tabella.
      async function newContactDOM(event) {
        // Evito che il form venga davvero inviato.
        event.preventDefault();

        // Recuperi i dati da inviare dal form.
        const name = document.getElementById("input-name");
        const number = document.getElementById("input-number");
        let contact = {
          "name": name.value,
          "number": number.value
        };

        // Pulisco i campi del form, ormai non servono più.
        name.value = "";
        number.value = "";

        try {
          // Creo il nuovo oggetto e lo invio al server, restituisce il
          // nuovo ID.
          contact["id"] = await newContact(contact)

          // Ottengo il nuovo contatto con tutte le informazioni.
          contact = await getContact(contact["id"]);

          // Infine lo aggiungo alla tabella.
          addContactDOM(contact);
        } catch (error) {
          onError("Failed to add a new user", error);
        }
      }

      // addContactDOM aggiunge il contatto fornito in una nuova riga della tabella.
      async function addProjectionDOM(projection) {
        // Selezione di <tbody> e aggiunta di una nuova riga.
        const tbody = document.getElementById("table-body");
        const row = tbody.insertRow();

        // Aggiunta dell'ID.
        const id = row.insertCell();
        id.setAttribute("align", "center");
        const idText = document.createTextNode(projection["id"]);
        id.appendChild(idText);

        // Aggiunta del nome.
        const idScreening = row.insertCell();
        idScreening.setAttribute("align", "center");
        const idScreeningText = document.createTextNode(projection["idScreening"]);
        idScreening.appendChild(idScreeningText);

        // Aggiunta del numero.
        const idMovie = row.insertCell();
        idMovie.setAttribute("align", "center");
        const idMovieText = document.createTextNode(projection["idMovie"]);
        try {
          let movie = await getMovie(idMovieText);
        } catch (error) {
          onError("Failed to get movie", error);
          return;
        }
        const keyNameText = document.createTextNode("Nome: ");
        const nameText = document.createTextNode(movie["name"]);
        idMovie.appendChild(nameText);
        idMovie.appendChild(document.createElement("br"));
        const keyGenreText = document.createTextNode("Genere: ");
        const genreText = document.createTextNode(movie["genre"]);
        idMovie.appendChild(genreText);
        idMovie.appendChild(document.createElement("br"));
        const keyDirectorText = document.createTextNode("Direttore: ");
        const directorText = document.createTextNode(movie["director"]);
        idMovie.appendChild(directorText);
        idMovie.appendChild(document.createElement("br"));
        const keyDurationText = document.createTextNode("Durata: ");
        const durationText = document.createTextNode(movie["duration"]);
        idMovie.appendChild(durationText);

        const date = row.insertCell();
        date.setAttribute("align", "center");
        const dateTemp = new Date(...projection["date"]);
        const dateText = document.createTextNode(dateTemp.toLocaleDateString("it-IT"));
        date.appendChild(dateText);

        const time = row.insertCell();
        time.setAttribute("align", "center");
        const timeText = document.createTextNode(projection["time"]);
        time.appendChild(timeText);

        //FARE LA SALA

        const actions = row.insertCell();
        actions.setAttribute("align", "center");
        const reservationButton = document.createElement("button");
        actions.appendChild(reservationButton);
        const reservationText = document.createTextNode("Reserve seats");
        reservationButton.appendChild(reservationText);
        reservationButton.addEventListener("click", () => {
          reserveSeatsDOM(hall);
        });
      }

      function reserveSeatsDOM(hall) {
        const table = document.createElement("table");
        table.setAttribute("border", "1");

        const postiRiga = document.createTextNode(hall["postiRiga"]);
        const postiColonna = document.createTextNode(hall["postiColonna"]);
        for (let i = 0; i < postiRiga; i++) {
          let tbody = document.createElement("tbody");
          const row = tbody.insertRow();
          for (let j = 0; j < postiColonna; j++) {
            const actions = row.insertCell();
            actions.setAttribute("align", "center");
            //ASSEGNARE RIGA-COLONNA AL CHECKBOX
            const checkbox = document.createElement("checkbox");
            actions.appendChild(checkbox);
          }
        }
      }

      // Ho definito init come una funzione asincrona, per cui l'esecuzione è slegata
      // dal flusso sequenziale dello script. Il browser si occupa di gestire queste
      // funzioni, che prima o poi verranno eseguite e completate.
      window.onload = init();

      async function init() {
        // getUsers è asincrona, per cui restituisce una Promise che verrà eseguita
        // in modo asincrono. Il metodo then permette di eseguire due funzioni: la
        // prima in caso di successo, la seconda in caso di errore.
        getProjections().then((projection) => projection.forEach(addProjectionDOM),
          (error) => onError("Failed to get users", error));

        // Aggiungo l'handler per l'evento di invio al form.
        //const form = document.getElementById("add-contact");
        //form.addEventListener("submit", newContactDOM);
      }

    </script>
  </body>

</html>
